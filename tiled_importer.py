# tiled_importer.py
import json
import os

def import_collision_from_tiled(tiled_json_path, existing_meta_path, collision_layer_name="CollisionLayer"):
    """
    Reads collision data from a Tiled JSON export and updates an existing map_meta.json.
    """
    try:
        with open(tiled_json_path, 'r') as f:
            tiled_data = json.load(f)
    except FileNotFoundError:
        print(f"Error: Tiled JSON file not found at {tiled_json_path}")
        return False
    except json.JSONDecodeError as e:
        print(f"Error decoding Tiled JSON file {tiled_json_path}: {e}")
        return False

    try:
        with open(existing_meta_path, 'r') as f:
            meta_data = json.load(f)
    except FileNotFoundError:
        print(f"Error: Existing metadata file not found at {existing_meta_path}. Run convert_map_to_tiles.py first.")
        return False
    except json.JSONDecodeError as e:
        print(f"Error decoding existing metadata file {existing_meta_path}: {e}")
        return False

    # --- Validate Tiled data and consistency with existing metadata ---
    if tiled_data.get("tilewidth") != meta_data.get("tile_pixel_width") or \
       tiled_data.get("tileheight") != meta_data.get("tile_pixel_height"):
        print("Error: Tile dimensions in Tiled JSON and map_meta.json do not match!")
        print(f"Tiled: {tiled_data.get('tilewidth')}x{tiled_data.get('tileheight')}, Meta: {meta_data.get('tile_pixel_width')}x{meta_data.get('tile_pixel_height')}")
        return False

    if tiled_data.get("width") != meta_data.get("grid_width_in_tiles") or \
       tiled_data.get("height") != meta_data.get("grid_height_in_tiles"):
        print("Error: Map grid dimensions in Tiled JSON and map_meta.json do not match!")
        print(f"Tiled: {tiled_data.get('width')}x{tiled_data.get('height')}, Meta: {meta_data.get('grid_width_in_tiles')}x{meta_data.get('grid_height_in_tiles')}")
        return False
    
    map_width_in_tiles = tiled_data["width"]
    map_height_in_tiles = tiled_data["height"]

    # --- Find the collision layer and extract its data ---
    collision_layer = None
    for layer in tiled_data.get("layers", []):
        if layer.get("name") == collision_layer_name and layer.get("type") == "tilelayer":
            collision_layer = layer
            break
    
    if not collision_layer:
        print(f"Error: Collision layer named '{collision_layer_name}' not found in {tiled_json_path}")
        return False

    tiled_collision_data_1d = collision_layer.get("data", [])
    if len(tiled_collision_data_1d) != map_width_in_tiles * map_height_in_tiles:
        print(f"Error: Collision data length in Tiled JSON ({len(tiled_collision_data_1d)}) does not match expected map size ({map_width_in_tiles * map_height_in_tiles}).")
        return False

    # --- Convert Tiled 1D GID array to our 2D collision_grid_data format ---
    # In Tiled, a GID of 0 on a tile layer means the tile is empty (walkable for our collision layer).
    # Any GID > 0 means a tile is present (non-walkable/wall for our collision layer).
    new_collision_grid = []
    for y in range(map_height_in_tiles):
        row = []
        for x in range(map_width_in_tiles):
            gid_index = y * map_width_in_tiles + x
            gid = tiled_collision_data_1d[gid_index]
            if gid > 0: # Any tile on the collision layer is a wall
                row.append(1) # Non-walkable
            else: # GID is 0 (empty)
                row.append(0) # Walkable
        new_collision_grid.append(row)

    # --- Update the metadata with the new collision grid ---
    meta_data["collision_grid_data"] = new_collision_grid
    
    try:
        with open(existing_meta_path, 'w') as f:
            json.dump(meta_data, f, indent=4)
        print(f"Successfully updated '{existing_meta_path}' with collision data from Tiled.")
        print("Collision Grid (sample top-left 5x5 or less - 0 is walkable, 1 is wall):")
        for i in range(min(5, map_height_in_tiles)):
            print(new_collision_grid[i][:min(5, map_width_in_tiles)])
        return True
    except IOError as e:
        print(f"Error writing updated metadata to {existing_meta_path}: {e}")
        return False

if __name__ == "__main__":
    tiled_exported_json_file = "tiled_campus_map.json" # Your Tiled export
    metadata_file_to_update = os.path.join("tiles", "map_meta.json") # Generated by convert_map_to_tiles.py

    if not os.path.exists(tiled_exported_json_file):
        print(f"Tiled export '{tiled_exported_json_file}' not found. Please export it from Tiled first.")
    elif not os.path.exists(metadata_file_to_update):
        print(f"Base metadata file '{metadata_file_to_update}' not found. Please run 'convert_map_to_tiles.py' first.")
    else:
        if import_collision_from_tiled(tiled_exported_json_file, metadata_file_to_update):
            print("Process complete. Your map_meta.json should now have accurate collision data.")
            print("You can now run your main.py game.")
        else:
            print("Failed to import collision data from Tiled.")